name: 'Patch Env Files'
description: 'Patch environment files with configuration values from JSON'
author: 'KoalaOps'

branding:
  icon: 'settings'
  color: 'purple'

inputs:
  path:
    description: 'Working directory path'
    required: false
    default: '.'
  patches:
    description: 'JSON object mapping file paths to key-value pairs. Can be base64 encoded. Example: {".env": {"KEY": "value"}}'
    required: true

outputs:
  updated_files:
    description: 'Comma-separated list of updated files'
    value: ${{ steps.apply.outputs.files }}

runs:
  using: 'composite'
  steps:
    - name: Decode patches
      id: decode
      shell: bash
      run: |
        PATCHES='${{ inputs.patches }}'
        
        # Check if it's base64 encoded
        if echo "$PATCHES" | base64 -d >/dev/null 2>&1; then
          echo "🔓 Decoding base64 patches..."
          DECODED=$(echo "$PATCHES" | base64 -d)
        else
          echo "📋 Using plain JSON patches..."
          DECODED="$PATCHES"
        fi
        
        # Validate JSON
        if ! echo "$DECODED" | jq empty 2>/dev/null; then
          echo "::error::Invalid JSON patches"
          echo "$DECODED"
          exit 1
        fi
        
        # Output decoded patches
        echo "patches<<EOF" >> $GITHUB_OUTPUT
        echo "$DECODED" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "✓ Patches validated"
    
    - name: Apply patches to env files
      id: apply
      shell: bash
      working-directory: ${{ inputs.path }}
      run: |
        echo "🔧 Applying patches to environment files..."
        
        PATCHES='${{ steps.decode.outputs.patches }}'
        UPDATED_FILES=""
        
        # Process each file and its patches (using process substitution to avoid subshell)
        while IFS= read -r entry; do
          FILE_PATH=$(echo "$entry" | jq -r '.key')
          FILE_PATCHES=$(echo "$entry" | jq -r '.value')
          
          echo "📝 Patching: $FILE_PATH"
          
          # Create parent directory if needed
          DIR=$(dirname "$FILE_PATH")
          if [ "$DIR" != "." ] && [ ! -d "$DIR" ]; then
            mkdir -p "$DIR"
            echo "  Created directory: $DIR"
          fi
          
          # Create env file if it doesn't exist
          if [ ! -f "$FILE_PATH" ]; then
            touch "$FILE_PATH"
            echo "  Created new file: $FILE_PATH"
          fi
          
          # Apply each key-value pair (using process substitution here too)
          while IFS='=' read -r key value; do
            # Escape special characters for sed
            escaped_key=$(echo "$key" | sed 's/[[\.*^$()+?{|]/\\&/g')
            
            # Check if key exists and track change type
            # Match both "KEY=value" and key-only "KEY" lines (with optional trailing whitespace)
            if grep -q "^${escaped_key}\(=\|[[:space:]]*$\)" "$FILE_PATH"; then
              sed -i.bak "/^${escaped_key}\(=\|[[:space:]]*$\)/d" "$FILE_PATH" && rm "${FILE_PATH}.bak"
              echo "  ✏️  Updated: $key"
            else
              echo "  ➕ Added: $key"
            fi
            
            # Add new value
            echo "$key=$value" >> "$FILE_PATH"
          done < <(echo "$FILE_PATCHES" | jq -r 'to_entries[] | "\(.key)=\(.value)"')
          
          # Track updated files
          if [ -z "$UPDATED_FILES" ]; then
            UPDATED_FILES="$FILE_PATH"
          else
            UPDATED_FILES="$UPDATED_FILES,$FILE_PATH"
          fi
        done < <(echo "$PATCHES" | jq -r 'to_entries[] | @json')
        
        echo "files=$UPDATED_FILES" >> $GITHUB_OUTPUT
        echo "✓ Patches applied successfully"
    
    - name: Show summary
      shell: bash
      working-directory: ${{ inputs.path }}
      run: |
        echo "📊 Summary of patches:"
        echo '${{ steps.decode.outputs.patches }}' | jq -r '
          to_entries[] |
          "  📁 \(.key): \(.value | length) key(s) patched"
        '